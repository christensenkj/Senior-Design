/*
 * main.c
 *
 * Communicates on I2C between SHTC3 Temperature and Humidity Sensor
 * on the USCIB0 module. Starts on the interrupt of a TIMERA0 every 5 seconds
 *
 *  Created on: Mar 28, 2021
 *      Author: Zach Wilson
 */

#include <msp430.h>
#include <stdint.h>

#define TIMER_TIME 15938                    // Timer A for 5 seconds plz

void shtc3_i2c(void);
void Wakeup(void);
void Measure(void);
void Read(void);
void Sleep(void);
void Interpret(void);

volatile uint8_t TXByteCtr;
volatile uint8_t *TXData;
volatile uint8_t RXByteCtr;
volatile uint8_t *RXData;
volatile uint8_t RXBuff[6];
//volatile uint8_t RXReady;
volatile uint8_t SHTC3_ready;
volatile uint8_t I2C_flag;
volatile uint32_t RH;
volatile uint32_t TP;
volatile float Humid;
volatile float Temp;

void main(void)
{

    WDTCTL = WDTPW | WDTHOLD;                // Stop watchdog timer

    // Setting the pins for I2C communication to SHTC3 via USCIB0 on MSP430F5529

        // P1.0: Red LED (for debugging haha, like that's going to happen)
        P1DIR |= BIT0;
        P1OUT &= ~BIT0;                     // LED starts off

        // P3.0: SDA on USCIB0
        P3SEL |= BIT0;

        // P3.1: SCL on USCIB0
        P3SEL |= BIT1;

    // Configuration for TimerA0
    TA0CCTL0 |= CCIE;                       // Enable timer interrupt
    TA0CTL = TASSEL_2 | ID_3 | MC_1;        // Set Timer A to SMCLK/8 = ; Count up to TA0CCR0
    TA0CTL |= TACLR;                        // Good idea before starting

    // Configuration for I2C on USCIB0
    UCB0CTL1 |= UCSWRST;
    UCB0CTL0 |= UCMST + UCSYNC + UCMODE_3;  // I2C master mode; Synchronous; I2C Mode
    UCB0CTL1 = UCSSEL_2 + UCSWRST;          // Set SMCLK for I2C
    UCB0BR0 = 255;                          // fSCL = SMCLK/255 = appx 100kHz
    UCB0BR1 = 0;
    UCB0I2CSA = 0x70;                       // SHTC3 address
    UCB0CTL1 &= ~UCSWRST;

    SHTC3_ready = 0;                        // Don't enable temp/humid right away
    RH = 0x00;

    __bis_SR_register(GIE);                 // Enable global interrupts

    TA0CCR0 = TIMER_TIME;                   // Start the timer initially

    while(1)
    {
        if (SHTC3_ready == 1)
        {
            SHTC3_ready = 0;                // Only do this once at a time
            shtc3_i2c();                    // Initiate communication
        }
    }

}

void shtc3_i2c(void)
{
    UCB0IE |= UCTXIE + UCRXIE;              // Enable TX and RX interrupts on I2C
    Wakeup();
    Measure();
    UCB0IFG &= ~UCNACKIFG;                  // Clear Nack interrupt flag
    UCB0IE |= UCNACKIE;                     // Enable Nack interrupts
    Read();
    UCB0IE &= ~UCNACKIE;
    Sleep();
    Interpret();
    P1OUT &= ~BIT0;                         // Reset the LED to prove out of I2C
}

void Wakeup(void)
{
    UCB0CTL1 |= UCTR;                       // Set as transmitter
    while (UCB0CTL1 & UCTXSTP);
    TXByteCtr = 2;                          // Load TX Byte Counter
    uint8_t wakeup_command[] = {0x35,0x17}; // Wakeup command for SHTC3
    TXData = (uint8_t *)wakeup_command;     // Grab the pointer for the command
    I2C_flag = 1;
    UCB0CTL1 |= UCTXSTT;                    // TX start
    while(I2C_flag);
    while (UCB0CTL1 & UCTXSTP);             // Ensure 1st stop sent before continuing
    __delay_cycles(100);                    // Waking up takes time. Let the baby arise
}

void Measure(void)
{
    UCB0CTL1 |= UCTR;                       // Set as transmitter
    TXByteCtr = 2;                          // Load TX Byte counter
    uint8_t measure_command[] = {0x58,0xE0};// Measure command for low power mode and no clock stretching
    TXData = (uint8_t *)measure_command;    // Grab the pointer for the command
    I2C_flag = 1;
    UCB0CTL1 |= UCTXSTT;                    // TX start
    while(I2C_flag);
    while (UCB0CTL1 & UCTXSTP);             // Ensure 2nd stop sent before continuing
}

void Read(void)
{
    UCB0CTL1 &= ~UCTR;                      // Set as receiver
    RXByteCtr = 6;                          // Load RX Byte counter
    RXData = (uint8_t *)RXBuff;             // Set pointer to the buffer
    //RXReady = 0;                          // Initiate the flag for polling
    I2C_flag = 1;
    UCB0CTL1 |= UCTXSTT;
    while(I2C_flag);
    while (UCB0CTL1 & UCTXSTP);
}

void Sleep(void)
{
    UCB0CTL1 |= UCTR;                       // Set as transmitter
    TXByteCtr = 2;                          // Load TX Byte counter
    uint8_t sleep_command[] = {0xB0,0x98};  // Sleep command
    TXData = (uint8_t *)sleep_command;      // Grab pointer to the command
    I2C_flag = 1;
    UCB0CTL1 |= UCTXSTT;                    // TX Start
    while(I2C_flag);
    while (UCB0CTL1 & UCTXSTP);             // Ensure 4th stop condition sent
}

void Interpret(void)
{
    RH = (RXBuff[5] << 8) | RXBuff[4];
    RH = RH & 0x0000FFFF;
    TP = (RXBuff[2] << 8) | RXBuff[1];
    TP = TP & 0x0000FFFF;
    //RH = RH << 8;
    //RH = RH | RXBuff[1];
    //int RelHum = (int)RH;
    Humid = (float)(100*((float)RH/65536));
    Temp = (float)(32 + 1.8*(-45 + 175*((float)TP/65536)));
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void timerA_ISR (void)
{
    P1OUT |= BIT0;                          // LED turns on to indicate start of I2C transaction
    // Temporary measure to ensure we don't get another interrupt during I2C for now
        TA0CCR0 = 0x00;                     // Clears timer
    //shtc3_i2c();
    SHTC3_ready = 1;                        // Enable turning on SHTC3
}

#pragma vector = USCI_B0_VECTOR
__interrupt void I2C_ISR (void)
{
    switch(__even_in_range(UCB0IV,12))
    {
    case 0: break;                          // Vector 0: No interrupts
    case 2: break;                          // Vector 2: ALIFG
    case 4:                                 // Vector 4: NACKIFG
        UCB0IFG &= ~UCNACKIFG;                  // Clear the interrupt flag
        //while (UCB0CTL1 & UCTXSTP);             // Wait for a stop before trying again
        UCB0CTL1 |= UCTXSTT;                    // Start condition
        break;
    case 6: break;                          // Vector 6: STTIFG
    case 8: break;                          // Vector 8: STPIFG
    case 10:                                // Vector 10: RXIFG
        //RXReady = 1;                          // In the RX zone now
        RXByteCtr--;                            // Decrement RX Byte Counter
        if (RXByteCtr)
        {
            *(RXData + RXByteCtr) = UCB0RXBUF;  // Move RX Buffer data into local buffer
            if (RXByteCtr == 1)                 // 1 byte left
            {
                UCB0CTL1 |= UCTXSTP;            // I2C stop condition
                I2C_flag = 0;
            }
        }
        else
        {
            *RXData = UCB0RXBUF;                // Move last byte into the local buffer
        }
        break;
    case 12:                                // Vector 12: TXIFG
        if (TXByteCtr)
        {
            UCB0TXBUF = *(TXData++);            // Load TX Buffer
            TXByteCtr--;                        // Decrement TX byte counter
        }
        else
        {
            UCB0CTL1 |= UCTXSTP;                // Send stop condition
            I2C_flag = 0;
            UCB0IFG &= ~UCTXIFG;                // Clear TX interrupt flag
        }
        break;
    default: break;
    }
}
